

#@Andrew - need to document
#'
#'@param weights An object of class 'jheem.likelihood.weights', generated by \code{\link{create.likelihood.weights}}
#'
#'@export
create.basic.likelihood.instructions <- function(outcome.for.data,
                                                 outcome.for.sim,
                                                 denominator.outcome.for.sim = NULL, # If NULL (as it would be for population), will be doing the Poisson version of compute
                                                 dimensions,
                                                 denominator.dimensions = dimensions,
                                                 levels.of.stratification = NULL,
                                                 from.year = -Inf,
                                                 to.year = Inf,
                                                 omit.years = NULL,
                                                 sources.to.use = NULL,
                                                 correlation.different.years = 0.5,
                                                 correlation.different.strata = 0.1,
                                                 correlation.different.sources = 0.3,
                                                 correlation.same.source.different.details = 0.3,
                                                 observation.correlation.form = c('compound.symmetry', 'autoregressive.1')[1],
                                                 measurement.error.coefficient.of.variance,
                                                 weights,
                                                 equalize.weight.by.year = F)
{
    
    JHEEM.BASIC.LIKELIHOOD.INSTRUCTIONS$new(outcome.for.data = outcome.for.data,
                                            outcome.for.sim = outcome.for.sim,
                                            denominator.outcome.for.sim = denominator.outcome.for.sim,
                                            dimensions = dimensions,
                                            denominator.dimensions = denominator.dimensions,
                                            levels.of.stratification = levels.of.stratification,
                                            from.year = from.year,
                                            to.year = to.year,
                                            omit.years = omit.years,
                                            sources.to.use = sources.to.use,
                                            correlation.different.years = correlation.different.years,
                                            correlation.different.strata = correlation.different.strata,
                                            correlation.different.sources = correlation.different.sources,
                                            correlation.same.source.different.details = correlation.same.source.different.details,
                                            observation.correlation.form = observation.correlation.form,
                                            measurement.error.coefficient.of.variance = measurement.error.coefficient.of.variance,
                                            weights = weights,
                                            equalize.weight.by.year = equalize.weight.by.year
    )
    
}

JHEEM.BASIC.LIKELIHOOD.INSTRUCTIONS = R6::R6Class(
    'jheem.basic.likelihood.instructions',
    inherit = JHEEM.LIKELIHOOD.INSTRUCTIONS,
    
    public = list(
        
        initialize = function(outcome.for.data,
                              outcome.for.sim,
                              denominator.outcome.for.sim,
                              dimensions,
                              denominator.dimensions,
                              levels.of.stratification,
                              from.year,
                              to.year,
                              omit.years,
                              sources.to.use,
                              correlation.different.years,
                              correlation.different.strata,
                              correlation.different.sources,
                              correlation.same.source.different.details,
                              observation.correlation.form,
                              measurement.error.coefficient.of.variance,
                              weights,
                              equalize.weight.by.year)
        {
            super$initialize(outcome.for.data = outcome.for.data,
                             outcome.for.sim = outcome.for.sim,
                             from.year,
                             to.year,
                             omit.years,
                             dimensions = dimensions,
                             denominator.dimensions = denominator.dimensions,
                             levels.of.stratification = levels.of.stratification,
                             weights = weights,
                             equalize.weight.by.year = equalize.weight.by.year,
                             likelihood.class.generator = JHEEM.BASIC.LIKELIHOOD) # pass error prefix?
            
            error.prefix = paste0('Error creating basic likelihood instructions: ')
            
            if (!is.character(outcome.for.data) || length(outcome.for.data) > 1 || is.null(outcome.for.data) || is.na(outcome.for.data))
                stop(paste0(error.prefix, "'outcome.for.data' must be a character vector of length 1"))
            if (!is.character(outcome.for.sim) || length(outcome.for.sim) > 1 || is.null(outcome.for.sim) || is.na(outcome.for.sim))
                stop(paste0(error.prefix, "'outcome.for.sim' must be a character vector of length 1"))
            
            correlation.multipliers = c(correlation.different.years=correlation.different.years,
                                        correlation.different.strata=correlation.different.strata,
                                        correlation.different.sources=correlation.different.sources,
                                        correlation.same.source.different.details=correlation.same.source.different.details
            )
            
            for (i in seq_along(correlation.multipliers)) {
                if (!is.numeric(correlation.multipliers[[i]]) || correlation.multipliers[[i]] > 1 || correlation.multipliers[[i]] < 0)
                    stop(paste0(error.prefix, "'", names(correlation.multipliers)[[i]], "' must be an integer between 0 and 1 inclusive"))
            }
            
            # *observation.correlation.form* must be either 'compound.symmetry' or 'autoregressive.1'
            if (!(observation.correlation.form %in% c('compound.symmetry', 'autoregressive.1')) || length(observation.correlation.form) > 1)
                stop(paste0(error.prefix, "'observation.correlation.form' must be either 'compound.symmetry' or 'autoregressive.1'"))
            
            # *measurement.error.coefficient.of.variance* must be ...?
            
            
            private$i.sources.to.use = sources.to.use
            private$i.parameters = list(correlation.different.years = correlation.different.years,
                                        correlation.different.strata = correlation.different.strata,
                                        correlation.different.sources = correlation.different.sources,
                                        correlation.same.source.different.details = correlation.same.source.different.details,
                                        observation.correlation.form = observation.correlation.form,
                                        measurement.error.coefficient.of.variance = measurement.error.coefficient.of.variance
            )
        },
        
        equals = function(other)
        {
            stop("@Andrew redefine this")
        }
        
    ),
    
    active = list(
        
        parameters = function(value) {
            if (missing(value)) {
                private$i.parameters
            }
            else
                stop("Cannot modify a jheem.basic.likelihood.instruction's 'parameters' - they are read-only")
        },
        sources.to.use = function(value) {
            if (missing(value)) {
                private$i.sources.to.use
            }
            else
                stop("Cannot modify a jheem.basic.likelihood.instruction's 'sources.to.use' - they are read-only")
        }
        
    ),
    
    private = list(
        i.parameters = NULL,
        i.sources.to.use = NULL
    )
)

# class generator object
JHEEM.BASIC.LIKELIHOOD = R6::R6Class(
    'jheem.basic.likelihood',
    inherit = JHEEM.LIKELIHOOD,
    portable = F,
    
    public = list(
        
        initialize = function(instructions,
                              version,
                              location, #combinations of version and location tell us sublocations
                              data.manager,
                              throw.error.if.no.data,
                              error.prefix)
        {
            super$initialize(instructions = instructions,
                             version = version,
                             location = location,
                             data.manager = data.manager,
                             error.prefix = error.prefix)
            # ptm = proc.time()
            private$i.outcome.for.data = instructions$outcome.for.data
            private$i.outcome.for.sim = instructions$outcome.for.sim
            
            
            ## ---- DETERMINE YEARS ---- ##
            
            from.year = instructions$from.year
            to.year = instructions$to.year
            if (from.year == -Inf || to.year == Inf) {
                data.manager.bounds = data.manager$get.year.bounds.for.outcome(private$i.outcome.for.data)
                if (from.year == -Inf)
                    from.year = data.manager.bounds[['earliest.year']]
                if (to.year == Inf)
                    to.year = data.manager.bounds[['latest.year']]
            }
            private$i.years = setdiff(from.year:to.year, instructions$omit.years)
            
            
            ## ---- PREPARE DATA STRUCTURES ---- ##
            
            sim.metadata = get.simulation.metadata(version=version,
                                                   location=location,
                                                   from.year = private$i.years[[1]],
                                                   to.year = private$i.years[[length(private$i.years)]])
            
            if(!(private$i.outcome.for.sim %in% sim.metadata$outcomes))
                stop(paste0(error.prefix, private$i.outcome.for.sim, " is not a simulation outcome in this specification"))
            
            private$i.obs.vector = c()
            
            private$i.details = list() # details can't be in a data frame because its elements (character vectors) may have different lengths
            private$i.metadata = data.frame(year = character(0),
                                            stratum = character(0),
                                            source = character(0)
            )
            
            private$i.sim.ontology = sim.metadata$outcome.ontologies[[private$i.outcome.for.sim]]
            
            mappings.list = list()
            dimnames.list = list()
            private$i.transformation.matrix = NULL
            
            private$i.sim.keep.dimensions = c()
            # browser()
            
            ## ---- PULL DATA ---- ##
            
            for (strat in private$i.stratifications) {
                # print(strat)
                # browser()
                data = data.manager$pull(outcome = private$i.outcome.for.data,
                                         sources = private$i.sources.to.use,
                                         keep.dimensions = c('year', strat),
                                         dimension.values = list(location=location), # leave this for now. Will get more complicated when we have multi location models
                                         target.ontology = private$i.sim.ontology,
                                         allow.mapping.from.target.ontology = T,
                                         append.attributes = 'details',
                                         debug = F)
                
                
                one.mapping = attr(data, 'mapping')
                
                if (is.null(data)) {
                    if (throw.error.if.no.data)
                        stop(paste0(error.prefix, "no data was found for the stratification '", strat, "'"))
                    else {
                        one.sim.keep.dimensions = NULL
                        one.metadata = NULL
                    }
                }
                else {
                    one.sim.keep.dimensions = one.mapping$get.required.from.dimensions(to.dimensions = names(dim(data))[names(dim(data)) != 'source'])
                    
                    # Metadata will involve melting both arrays (data and details) as well as making "stratum"
                    one.metadata = reshape2::melt(data)
                    one.metadata = one.metadata[, sort(colnames(one.metadata))]
                    one.metadata['stratum'] = do.call(paste, c(subset.data.frame(one.metadata, select=-c(year, source, value)), sep="__"))
                    one.metadata = subset.data.frame(one.metadata, select = c(year, stratum, source))
                }
                    
                
                one.dimnames = dimnames(data)
                one.obs.vector = as.numeric(data)
                one.details = attr(data, 'details')
                
                private$i.obs.vector = c(private$i.obs.vector, one.obs.vector)
                private$i.details = c(private$i.details, one.details)
                private$i.metadata = rbind(private$i.metadata, one.metadata)
                
                private$i.sim.keep.dimensions = union(private$i.sim.keep.dimensions, one.sim.keep.dimensions)
                
                # save all the one.mappings in a list?
                mappings.list[[length(mappings.list) + 1]] = one.mapping
                dimnames.list[[length(dimnames.list) + 1]] = one.dimnames
                
            }

            ## ---- GENERATE TRANSFORMATION MATRIX ---- ##
            # browser()
            # extending.length.by = numeric(0)
            print('generating transformation matrix')

            for (s in seq_along(mappings.list)) {
                one.mapping = mappings.list[[s]]
                one.dimnames = dimnames.list[[s]]
                
                one.transformation.matrix = one.mapping$get.matrix(from.dim.names = private$i.sim.ontology[private$i.sim.keep.dimensions],
                                                                   to.dim.names = one.dimnames[names(one.dimnames) != 'source'])
                
                # extending.length.by = c(extending.length.by, dim(one.transformation.matrix)[[1]])
                
                # rbind once per source
                for (source in 1:length(one.dimnames[['source']])) {
                    private$i.transformation.matrix = rbind(private$i.transformation.matrix, one.transformation.matrix)
                }
                
                
            }
            # browser()
            remove.mask = is.na(private$i.obs.vector)
            private$i.obs.vector = private$i.obs.vector[!remove.mask]
            private$i.details = private$i.details[!remove.mask]
            private$i.metadata = private$i.metadata[!remove.mask,]
            private$i.transformation.matrix = private$i.transformation.matrix[!remove.mask,]
            
            if (is.null(private$i.transformation.matrix))
                stop(paste0(error.prefix, "no mappings found to align simulation and data ontologies"))
            
            ## ---- GENERATE SPARSE REPRESENTATIONS OF TRANSFORMATION MATRIX ---- ##
            private$i.transformation.matrix.indices = generate_transformation_matrix_indices(private$i.transformation.matrix,
                                                                                                 length(private$i.obs.vector),
                                                                                                 length(private$i.transformation.matrix) / length(private$i.obs.vector))
            private$i.transformation.matrix.row.oriented.indices = generate_transformation_matrix_row_oriented_indices(private$i.transformation.matrix,
                                                                                                                       length(private$i.obs.vector),
                                                                                                                       length(private$i.transformation.matrix) / length(private$i.obs.vector))
            
            ## ---- GENERATE MEASUREMENT ERROR COVARIANCE MATRIX ---- ##
            
            measurement.error.correlation.matrix = sapply(seq_along(private$i.obs.vector), function(i) {
                sapply(seq_along(private$i.obs.vector), function(j) {
                    private$i.parameters$correlation.different.years ^ (private$i.metadata[[i,'year']] != private$i.metadata[[j,'year']]) *
                        private$i.parameters$correlation.different.strata ^ (private$i.metadata[[i,'stratum']] != private$i.metadata[[j,'stratum']]) *
                        private$i.parameters$correlation.different.source ^ (private$i.metadata[[i,'source']] != private$i.metadata[[j,'source']]) *
                        private$i.parameters$correlation.same.source.different.details ^ (private$i.metadata[[i,'source']] == private$i.metadata[[j,'source']] &&
                                                                                                   !setequal(private$i.details[[i]], private$i.details[[j]]))
                })
            })
            
            measurement.error.sd = private$i.obs.vector * private$i.parameters$measurement.error.coefficient.of.variance
            
            private$i.measurement.error.covariance.matrix =
                measurement.error.correlation.matrix * (measurement.error.sd %*% t(measurement.error.sd))
            
            
            ## ---- GENERATE INVERSE VARIANCE WEIGHTS MATRIX ---- ##
            
            weights.vector = rep(1,length(private$i.obs.vector))
            
            if (instructions$equalize.weight.by.year) {
                obs.per.year = table(private$i.metadata[['year']])
                for (year in names(obs.per.year)) {
                    weights.vector[private$i.metadata[['year']] == year]  = 1 / obs.per.year[[year]]
                }
            }
            
            stratum.names = lapply(private$i.metadata$stratum, function(x) {
                unlist(strsplit(x, "__"))
            })
            
            # Once the weights list is in the format list(weights.object1, weights.object2, ...), I'll loop over them.
            for (weight in private$i.weights) {
                
                # if no dimension.values, apply it to all observations
                if (length(weight$dimension.values) == 0) {
                    weights.vector = weights.vector * weight$total.weight
                } else {
                    weights.mask = sapply(stratum.names, function(x) {
                        contains.dimension.value = F
                        if (length(x) == length(weight$dimension.values)) {
                            for (d in seq_along(x)) {
                                # NOTE: This assumes the dimensions of the dimension.values are sorted alphabetically. The stratum names are.
                                if (x[[d]] %in% weight$dimension.values[[d]])
                                    contains.dimension.value = T
                                else {
                                    contains.dimension.value = F
                                    break
                                }
                            }
                        }
                        contains.dimension.value
                        
                        })
                    weights.vector[weights.mask] = weights.vector[weights.mask] * weight$total.weight
                }
            }

            sqrt.weights.vector = sqrt(1/weights.vector)
            private$i.inverse.variance.weights.matrix = sqrt.weights.vector %*% t(sqrt.weights.vector)
            browser()
            
                
            
        },
        check = function() {
            browser()
        }
    ),
    
    private = list(
        
        i.outcome.for.data = NULL,
        i.outcome.for.sim = NULL,
        i.years = NULL,

        i.obs.vector = NULL,
        i.details = NULL,
        i.metadata = NULL,
        i.sim.ontology = NULL,
        i.sim.keep.dimensions = NULL,
        i.transformation.matrix = NULL,
        i.transformation.matrix.indices = NULL,
        i.transformation.matrix.row.oriented.indices = NULL,
        i.measurement.error.covariance.matrix = NULL,
        i.inverse.variance.weights.matrix = NULL, #not yet defined anywhere
        
        do.compute = function(sim, log=T, check.consistency=T)
        {
            
            
            
            # sim.data = sim$get() # fill out arguments (get the n and the p)
            # for now, assume I have n and p
            # runtime.
            # make private variables as needed; the initialize function will make those
            # will only do 1 call to get for the main outcome (new diagnoses or prevalence) and another for
            

            
            # make some fake sim data
            # do_compute() returns whatever mvtnorm needs
            browser()
            
            sim.numerator.data = sim$get(
                outcome = private$i.outcome.for.sim,
                keep.dimensions = private$i.sim.keep.dimensions
            )
            
            # I'll need to figure out what the keep.dimensions should be. Is it just exactly what the user specified it should be in the instructions?
            # sim.denominator.data = sim$get(
            #     outcome = private$i.denominator.outcome.for.sim,
            #     keep.dimensions = private$i.sim.keep.dimensions
            # )
            
            # need to have another argument for the denominator outcome for the sim
            # if it is NULL, use the Poisson approximation
            
            # transformed.numerator.data = private$i.transformation.matrix %*% sim.numerator.data
            # 
            # model.imperfection.error.variance =
            #     sim.numerator.data * (1 - sim.numerator.data / sim.denominator.data)
            # model.imperfection.error.covariance.matrix = diag(model.imperfection.error.variance, nrow=length(model.imperfection.error.variance), ncol=length(model.imperfection.error.variance))
            # 
            # transformed.model.imperfection.error.covariance.matrix =
            #     private$i.transformation.matrix %*%
            #     model.imperfection.error.covariance.matrix %*%
            #     t(private$i.transformation.matrix)
            # 
            # # sigma
            # overall.covariance.matrix = private$i.measurement.error.covariance.matrix + transformed.model.imperfection.error.covariance.matrix
            # mvtnorm::dmvnorm(
            #     private$i.obs.vector,
            #     mean = transformed.numerator.data,
            #     sigma = overall.covariance.matrix,
            #     log=T,
            #     checkSymmetry = F)
            sim.numerator.data = rep(10, length(private$i.obs.vector))
            sim.denominator.data = rep(20, length(private$i.obs.vector))
            sigma = get_basic_likelihood_sigma(sim.numerator.data,
                                             sim.denominator.data,
                                             private$i.transformation.matrix.indices,
                                             private$i.measurement.error.covariance.matrix,
                                             length(private$i.obs.vector),
                                             sigma = numeric(length(private$i.obs.vector) ^ 2) # maybe define before this?
            )
            
            mean = get_basic_likelihood_mean(sim.numerator.data,
                                            private$i.transformation.matrix.row.oriented.indices,
                                            length(private$i.obs.vector),
                                            mean = numeric(length(private$i.obs.vector))
            )
            
            # browser()
            # # --- #
            
            
            # apply weights in R
            
            sigma = sigma * private$i.inverse.variance.weights.matrix
            
            mvtnorm::dmvnorm(private$i.obs.vector,
                             mean = mean,
                             sigma = matrix(sigma, nrow=length(private$i.obs.vector), ncol=length(private$i.obs.vector)),
                             log=T,
                             checkSymmetry = F)


            browser()
            
        }
    )
)