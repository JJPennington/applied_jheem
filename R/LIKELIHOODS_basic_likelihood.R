

#@Andrew - need to document
#'
#'@param outcome.for.data A single character vector specifying the outcome that data managers will use to find data.
#'@param outcome.for.sim A single character vector specifying the simulation outcome to use.
#'@param denominator.outcome.for.sim (Optional) A single character vector specifying the simulation outcome to use a denominator if the outcome.for.sim is a ratio, proportion, or rate.
#'@param dimensions A character vector of dimensions, excluding year, from which stratifications will be generated.
#'@param denominator.dimensions (Optional) Analogous to 'dimensions' but for the simulation denominator outcome when applicable. Must be a subset of 'dimensions'.
#'@param levels.of.stratification An integer vector specifying how the dimensions should be combined to form strata. '0' indicates totals (not stratified) while '1' indicates strata that are each stratified by one dimension at a time, '2' indicates strat that are each stratified by a combination of two dimensions at a time, etc. May not exceed the number of dimensions. Defaults to NULL, which is equivalent to '0'.
#'@param from.year -Inf or a single integer value specifying the earliest year for which data should be pulled.
#'@param to.year Inf or a single integer value specifying the latest year for which data should be pulled.
#'@param omit.years (Optional) An integer vector of years to ignore.
#'@param sources.to.use A character vector of sources from which to pull data.
#'@param correlation.different.years A single numeric value specifying the correlation between observations of different years.
#'@param correlation.different.strata A single numeric value specifying the correlation between observations from different strata.
#'@param correlation.different.sources A single numeric value specifying the correlation between observations from different sources.
#'@param correlation.same.source.different.details A single numeric value specifying the correlation between observations of the same source but which have different 'details'.
#'@param observation.correlation.form Which correlation form to use in building the measurement error covariance matrix. May be 'compound.symmetry' or 'autoregressive.1'.
#'@param measurement.error.coefficient.of.variance A single numeric value specyfing the coefficient of variance used to build the measurement error covariance matrix.
#'@param weights A list containing only numeric vectors and objects of class 'jheem.likelihood.weights', which are generated by \code{\link{create.likelihood.weights}}
#'@param equalize.weight.by.year A Boolean indicating whether every year should be weighted equally before the weights from 'weights' are applied.
#'
#'@export
create.basic.likelihood.instructions <- function(outcome.for.data,
                                                 outcome.for.sim,
                                                 denominator.outcome.for.sim = NULL, # If NULL (as it would be for population), will be doing the Poisson version of compute
                                                 dimensions,
                                                 denominator.dimensions = dimensions,
                                                 levels.of.stratification = NULL,
                                                 from.year = -Inf,
                                                 to.year = Inf,
                                                 omit.years = NULL,
                                                 sources.to.use = NULL,
                                                 correlation.different.years = 0.5,
                                                 correlation.different.strata = 0.1,
                                                 correlation.different.sources = 0.3,
                                                 correlation.same.source.different.details = 0.3,
                                                 observation.correlation.form = c('compound.symmetry', 'autoregressive.1')[1],
                                                 measurement.error.coefficient.of.variance,
                                                 weights = list(),
                                                 equalize.weight.by.year = F)
{
    
    JHEEM.BASIC.LIKELIHOOD.INSTRUCTIONS$new(outcome.for.data = outcome.for.data,
                                            outcome.for.sim = outcome.for.sim,
                                            denominator.outcome.for.sim = denominator.outcome.for.sim,
                                            dimensions = dimensions,
                                            denominator.dimensions = denominator.dimensions,
                                            levels.of.stratification = levels.of.stratification,
                                            from.year = from.year,
                                            to.year = to.year,
                                            omit.years = omit.years,
                                            sources.to.use = sources.to.use,
                                            correlation.different.years = correlation.different.years,
                                            correlation.different.strata = correlation.different.strata,
                                            correlation.different.sources = correlation.different.sources,
                                            correlation.same.source.different.details = correlation.same.source.different.details,
                                            observation.correlation.form = observation.correlation.form,
                                            measurement.error.coefficient.of.variance = measurement.error.coefficient.of.variance,
                                            weights = weights,
                                            equalize.weight.by.year = equalize.weight.by.year
    )
    
}

JHEEM.BASIC.LIKELIHOOD.INSTRUCTIONS = R6::R6Class(
    'jheem.basic.likelihood.instructions',
    inherit = JHEEM.LIKELIHOOD.INSTRUCTIONS,
    
    public = list(
        
        initialize = function(outcome.for.data,
                              outcome.for.sim,
                              denominator.outcome.for.sim,
                              dimensions,
                              denominator.dimensions,
                              levels.of.stratification,
                              from.year,
                              to.year,
                              omit.years,
                              sources.to.use,
                              correlation.different.years,
                              correlation.different.strata,
                              correlation.different.sources,
                              correlation.same.source.different.details,
                              observation.correlation.form,
                              measurement.error.coefficient.of.variance,
                              weights,
                              equalize.weight.by.year)
        {
            
            
            error.prefix = paste0('Error creating basic likelihood instructions: ')
            
            # *outcome.for.sim* -- validated in the super$initialize
            
            # *outcome.for.data* is a single character vector
            if (!is.character(outcome.for.data) || length(outcome.for.data) > 1 || is.null(outcome.for.data) || is.na(outcome.for.data))
                stop(paste0(error.prefix, "'outcome.for.data' must be a character vector of length 1"))
            
            # *denominator.outcome.for.sim* is NULL or a single character vector
            if (!is.null(denominator.outcome.for.sim) && (!is.character(denominator.outcome.for.sim) || length(denominator.outcome.for.sim) > 1 || is.na(denominator.outcome.for.sim)))
                stop(paste0(error.prefix, "'denominator.outcome.for.sim' must be NULL or a character vector of length 1"))
            
            # *dimensions* -- validated in the super$initialize
            
            # *denominator.dimensions* is NULL or a character vector with no NAs or duplicates
            # AND which is a subset of *dimensions*
            if (!is.null(denominator.dimensions) && (!is.character(denominator.dimensions) || any(is.na(denominator.dimensions)) || any(duplicated(dimensions))) || length(setdiff(denominator.dimensions, dimensions)) > 0)
                stop(paste0(error.prefix, "'denominator dimensions' must be NULL or a character vector with no NAs or duplicates that is a subset of 'dimensions'"))
            
            # *levels.of.stratification* -- validated in the super$initialize
            
            # PROBLEM! INFINITY ISN'T INTEGER
            # *from.year* and *to.year* are single integer vectors. *to.year* must be larger than *from.year*.
            if (from.year != -Inf && (!is.integer(from.year) || length(from.year) > 1 || is.null(from.year) || is.na(from.year)))
                stop(paste0(error.prefix, "'from.year' must be -Inf or an integer vector of length 1"))
            if (to.year != Inf && (!is.integer(to.year) || length(to.year) > 1 || is.null(to.year) || is.na(to.year)))
                stop(paste0(error.prefix, "'to.year' must be Inf or an integer vector of length 1"))
            if (from.year > to.year)
                stop(paste0(error.prefix, "'from.year' must be less than 'to.year'"))
            
            # *omit.years* is NULL or a numeric vector containing no NAs or duplicates.
            if (!is.null(omit.years) && (!is.numeric(omit.years) || any(is.na(omit.years)) || any(duplicated(omit.years))))
                stop(paste0(error.prefix, "'omit.years' must be NULL or an integer vector containing no NAs or duplicates"))
            omit.years = as.integer(omit.years)
            
            # *sources.to.use* is NULL or a character vector containing no NAs or duplicates
            if (!is.null(sources.to.use) && (!is.character(sources.to.use) || any(is.na(sources.to.use)) || any(duplicated(sources.to.use))))
                stop(paste0(error.prefix, "'sources.to.use' must be NULL or a character vector containing no NAs or duplicates"))
            
            # *correlation.multipliers* are all single numeric vectors with values between 0 and 1 inclusive
            correlation.multipliers = c(correlation.different.years=correlation.different.years,
                                        correlation.different.strata=correlation.different.strata,
                                        correlation.different.sources=correlation.different.sources,
                                        correlation.same.source.different.details=correlation.same.source.different.details
            )
            for (i in seq_along(correlation.multipliers)) {
                if (!is.numeric(correlation.multipliers[[i]]) || length(correlation.multipliers[[i]]) > 1 || is.na(correlation.multipliers[[i]]) || correlation.multipliers[[i]] > 1 || correlation.multipliers[[i]] < 0)
                    stop(paste0(error.prefix, "'", names(correlation.multipliers)[[i]], "' must be a numeric value between 0 and 1 inclusive"))
            }
            
            # *observation.correlation.form* is either 'compound.symmetry' or 'autoregressive.1'
            if (length(observation.correlation.form) > 1 || !(observation.correlation.form %in% c('compound.symmetry', 'autoregressive.1')))
                stop(paste0(error.prefix, "'observation.correlation.form' must be either 'compound.symmetry' or 'autoregressive.1'"))
            
            # *measurement.error.coefficient.of.variance* must be a single numeric value between 0 and 1
            if (!is.numeric(measurement.error.coefficient.of.variance) || length(measurement.error.coefficient.of.variance) > 1 || is.na(measurement.error.coefficient.of.variance) || measurement.error.coefficient.of.variance > 1 || measurement.error.coefficient.of.variance < 0)
                stop(paste0(error.prefix, "'measurement.error.coefficient.of.variance' must be a numeric value between 0 and 1 inclusive"))
            
            # *weights* -- validated in the super$initialize
            
            # *equalize.weight.by.year* is a boolean
            if (!is.logical(equalize.weight.by.year) || length(equalize.weight.by.year) > 1 || is.null(equalize.weight.by.year) || is.na(equalize.weight.by.year))
                stop(paste0(error.prefix, "'equalize.weight.by.year' must be a single logical value (T/F)"))
            
            super$initialize(outcome.for.sim = outcome.for.sim,
                             dimensions = dimensions,
                             levels.of.stratification = levels.of.stratification,
                             weights = weights,
                             likelihood.class.generator = JHEEM.BASIC.LIKELIHOOD,
                             error.prefix = error.prefix)
            
            private$i.outcome.for.data = outcome.for.data
            private$i.denominator.outcome.for.sim = denominator.outcome.for.sim
            private$i.from.year = from.year
            private$i.to.year = to.year
            private$i.omit.years = omit.years
            private$i.denominator.dimensions = denominator.dimensions
            private$i.equalize.weight.by.year = equalize.weight.by.year
            private$i.sources.to.use = sources.to.use
            private$i.parameters = list(correlation.different.years = correlation.different.years,
                                        correlation.different.strata = correlation.different.strata,
                                        correlation.different.sources = correlation.different.sources,
                                        correlation.same.source.different.details = correlation.same.source.different.details,
                                        observation.correlation.form = observation.correlation.form,
                                        measurement.error.coefficient.of.variance = measurement.error.coefficient.of.variance)
        },
        
        equals = function(other)
        {
            if (!is(other, 'jheem.likelihood.instructions'))
                stop("'other' must be a 'jheem.likelihood.instructions' object")
            if (!is.null(self$code) && !is.null(other$code))
                self$code == other$code
            else {
                if (is(other, 'jheem.basic.likelihood.instructions'))
                {
                    to.compare.identical = c('description',
                                             'outcome.for.data',
                                             'outcome.for.sim',
                                             'denominator.outcome.for.sim',
                                             'from.year',
                                             'to.year')
                    to.compare.setequal = c('sources.to.use',
                                            'omit.years',
                                            'denominator.dimensions')
                    
                    all(sapply(to.compare.identical, function(x) {
                        identical(self[[x]], other[[x]])
                    })) &&
                        all(sapply(to.compare.setequal, function(x) {
                            setequal(self[[x]], other[[x]])
                        })) &&
                        all(sapply(self$weights, function(x) {any(sapply(other$weights, function(y) {
                                x$equals(y)
                            }))})) &&
                        all(sapply(names(self$parameters), function(x) {
                            self$parameters[[x]] == other$parameters[[x]]
                        })) &&
                        stratification.lists.equal(self$stratifications, other$stratifications)
                } else F
            }
        }
    ),
    
    active = list(
        
        outcome.for.data = function(value)
        {
            if (missing(value))
            {
                private$i.outcome.for.data
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'outcome.for.data' - it is read-only")
        },
        denominator.outcome.for.sim = function(value)
        {
            if (missing(value))
            {
                private$i.denominator.outcome.for.sim
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'denominator.outcome.for.sim' - it is read-only")
        },
        from.year = function(value)
        {
            if (missing(value))
            {
                private$i.from.year
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'from.year' - it is read-only")
        },
        to.year = function(value)
        {
            if (missing(value))
            {
                private$i.to.year
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'to.year' - it is read-only")
        },
        omit.years = function(value)
        {
            if (missing(value))
            {
                private$i.omit.years
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'omit.years' - they are read-only")
        },
        denominator.dimensions = function(value)
        {
            if (missing(value))
            {
                private$i.denominator.dimensions
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'denominator.dimensions' - they are read-only")
        },
        equalize.weight.by.year = function(value)
        {
            if (missing(value))
            {
                private$i.equalize.weight.by.year
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'equalize.weight.by.year' - it is read-only")
        },
        parameters = function(value)
        {
            if (missing(value)) {
                private$i.parameters
            }
            else
                stop("Cannot modify a jheem.basic.likelihood.instruction's 'parameters' - they are read-only")
        },
        sources.to.use = function(value)
        {
            if (missing(value)) {
                private$i.sources.to.use
            }
            else
                stop("Cannot modify a jheem.basic.likelihood.instruction's 'sources.to.use' - they are read-only")
        }
        
    ),
    
    private = list(
        i.outcome.for.data = NULL,
        i.denominator.outcome.for.sim = NULL,
        i.from.year = NULL,
        i.to.year = NULL,
        i.omit.years = NULL,
        i.denominator.dimensions = NULL,
        i.equalize.weight.by.year = NULL,
        i.parameters = NULL,
        i.sources.to.use = NULL
    )
)

# class generator object
JHEEM.BASIC.LIKELIHOOD = R6::R6Class(
    'jheem.basic.likelihood',
    inherit = JHEEM.LIKELIHOOD,
    portable = F,
    
    public = list(
        
        initialize = function(instructions,
                              version,
                              location, #combinations of version and location tell us sublocations
                              data.manager,
                              throw.error.if.no.data,
                              error.prefix)
        {
            super$initialize(instructions = instructions,
                             version = version,
                             location = location,
                             error.prefix = error.prefix)
            
            # Validate *data.manager*, a 'jheem.data.manager' object
            if (!R6::is.R6(data.manager) || !is(data.manager, 'jheem.data.manager'))
                stop("'data.manager' must be an R6 object with class 'jheem.data.manager'")
            
            private$i.parameters = instructions$parameters
            private$i.outcome.for.data = instructions$outcome.for.data
            private$i.denominator.outcome.for.sim = instructions$denominator.outcome.for.sim
            
            
            ## ---- DETERMINE YEARS FOR SIM METADATA ---- ##
            years = get.likelihood.years(from.year = instructions$from.year,
                                         to.year = instructions$to.year,
                                         omit.years = instructions$omit.years,
                                         data.manager = data.manager,
                                         outcome.for.data = private$i.outcome.for.data)
            
            ## ---- PREPARE DATA STRUCTURES ---- ##
            
            sim.metadata = get.simulation.metadata(version=version,
                                                   location=location,
                                                   from.year = years[[1]],
                                                   to.year = years[[length(years)]])
            
            if(!(private$i.outcome.for.sim %in% sim.metadata$outcomes))
                stop(paste0(error.prefix, private$i.outcome.for.sim, " is not a simulation outcome in this specification"))
            
            private$i.sim.ontology = sim.metadata$outcome.ontologies[[private$i.outcome.for.sim]]
            private$i.sim.ontology[['year']] = as.character(years)
            
            private$i.obs.vector = c()
            
            private$i.details = list() # details can't be in a data frame because its elements (character vectors) may have different lengths
            private$i.metadata = data.frame(year = character(0),
                                            stratum = character(0),
                                            source = character(0)
            )

            mappings.list = list()
            dimnames.list = list()
            private$i.transformation.matrix = NULL
            private$i.sim.required.dimnames = list()
            

            remove.mask = c()

            ## ---- PULL DATA ---- ##
            
            for (strat in private$i.stratifications) {
                keep.dimensions = 'year'
                if (!identical(strat, "")) keep.dimensions = c(keep.dimensions, strat)
                data = data.manager$pull(outcome = private$i.outcome.for.data,
                                         sources = private$i.sources.to.use,
                                         keep.dimensions = keep.dimensions,
                                         dimension.values = list(location=location), # leave this for now. Will get more complicated when we have multi location models
                                         target.ontology = private$i.sim.ontology,
                                         allow.mapping.from.target.ontology = T,
                                         append.attributes = 'details',
                                         debug = F)
                
                
                one.mapping = attr(data, 'mapping')
                one.dimnames = dimnames(data)
                one.obs.vector = as.numeric(data)
                one.details = attr(data, 'details')
                
                one.remove.mask = is.na(one.obs.vector)
                remove.mask = c(remove.mask, one.remove.mask)
                one.obs.vector = one.obs.vector[!one.remove.mask]
                one.details = one.details[!one.remove.mask]
                
                if (is.null(data)) {
                    if (throw.error.if.no.data)
                        stop(paste0(error.prefix, "no data was found for the stratification '", strat, "'"))
                    else {
                        # one.sim.keep.dimensions = NULL
                        one.metadata = NULL
                        one.sim.required.dimnames = list()
                    }
                }
                else {
                    # one.sim.keep.dimensions = one.mapping$get.required.from.dimensions(to.dimensions = names(dim(data))[names(dim(data)) != 'source'])
                    
                    # Metadata will involve melting both arrays (data and details) as well as making "stratum"
                    one.metadata = reshape2::melt(data)
                    
                    one.metadata = one.metadata[!one.remove.mask,]
                    
                    # Recover required dimnames from one.metadata
                    one.sim.required.dimnames = one.mapping$get.required.from.dim.names(lapply(one.metadata[!(colnames(one.metadata) %in% c('source', 'value'))],
                                                                                           function(x) {as.character(unique(x))}))
                    
                    one.metadata = one.metadata[, sort(colnames(one.metadata))]
                    one.metadata['stratum'] = do.call(paste, c(subset.data.frame(one.metadata, select=-c(year, source, value)), sep="__"))
                    one.metadata[is.na(one.metadata$stratum), 'stratum'] = ".TOTAL."
                    one.metadata = subset.data.frame(one.metadata, select = c(year, stratum, source))
                }
                
                # Find the required.dimnames
                for (d in names(one.sim.required.dimnames)) {
                    
                    if (!(d %in% names(private$i.sim.required.dimnames)))
                        private$i.sim.required.dimnames = c(private$i.sim.required.dimnames, setNames(list(one.sim.required.dimnames[[d]]), d))
                    else
                        private$i.sim.required.dimnames[[d]] = union(private$i.sim.required.dimnames[[d]], one.sim.required.dimnames[[d]])
                }
                
                private$i.obs.vector = c(private$i.obs.vector, one.obs.vector)
                private$i.details = c(private$i.details, one.details)
                private$i.metadata = rbind(private$i.metadata, one.metadata)
                
                # save all the one.mappings in a list?
                mappings.list[[length(mappings.list) + 1]] = one.mapping
                dimnames.list[[length(dimnames.list) + 1]] = one.dimnames
                
            }
            
            ## ---- FIND REQUIRED DIMENSION VALUES, ETC. ---- ##
            private$i.sim.dimension.values = private$i.sim.required.dimnames[sapply(names(private$i.sim.required.dimnames),
                                                                                    function(d) {
                                                                                        !identical(private$i.sim.required.dimnames[[d]],
                                                                                                   private$i.sim.ontology[[d]])
                                                                                    })]
            denominator.keep.dimensions = c(instructions$denominator.dimensions, 'year')[c(instructions$denominator.dimensions, 'year') %in% names(private$i.sim.required.dimnames)]
            private$i.denominator.required.dimnames = private$i.sim.required.dimnames[names(private$i.sim.required.dimnames) %in% denominator.keep.dimensions]
            private$i.denominator.dimension.values = private$i.denominator.required.dimnames[sapply(names(private$i.denominator.required.dimnames),
                                                                                                    function(d) {
                                                                                                        !identical(private$i.denominator.required.dimnames[[d]],
                                                                                                                   private$i.sim.ontology[[d]])
                                                                                                    })]
            private$i.years = private$i.sim.required.dimnames[['year']]

            ## ---- GENERATE TRANSFORMATION MATRIX ---- ##
            # browser()
            # Some data has year ranges
            for (s in seq_along(mappings.list)) {
                one.mapping = mappings.list[[s]]
                one.dimnames = dimnames.list[[s]]
                
                one.transformation.matrix = one.mapping$get.matrix(from.dim.names = private$i.sim.required.dimnames,
                                                                   to.dim.names = one.dimnames[names(one.dimnames) != 'source'])
                # rbind once per source
                for (source in 1:length(one.dimnames[['source']])) {
                    private$i.transformation.matrix = rbind(private$i.transformation.matrix, one.transformation.matrix)
                }
            }
            private$i.transformation.matrix = private$i.transformation.matrix[!remove.mask,]
            
            if (is.null(private$i.transformation.matrix))
                stop(paste0(error.prefix, "no mappings found to align simulation and data ontologies"))
            
            ## ---- GENERATE SPARSE REPRESENTATIONS OF TRANSFORMATION MATRIX ---- ##
            private$i.transformation.matrix.indices = generate_transformation_matrix_indices(private$i.transformation.matrix,
                                                                                                 length(private$i.obs.vector),
                                                                                                 length(private$i.transformation.matrix) / length(private$i.obs.vector))

            private$i.transformation.matrix.row.oriented.indices = generate_transformation_matrix_row_oriented_indices(private$i.transformation.matrix,
                                                                                                                       length(private$i.obs.vector),
                                                                                                                       length(private$i.transformation.matrix) / length(private$i.obs.vector))

            ## ---- GENERATE MEASUREMENT ERROR COVARIANCE MATRIX ---- ##
            measurement.error.correlation.matrix = sapply(seq_along(private$i.obs.vector), function(i) {
                # if (i %% 100 == 0)
                #     print(paste0("Currently on i=", i, " with elapsed time from start of operation: ", (proc.time()-ptm)[['elapsed']]))
                sapply(seq_along(private$i.obs.vector), function(j) {

                    rv = 1
                    if (private$i.metadata[[i,'year']] != private$i.metadata[[j,'year']]) rv = rv * private$i.parameters$correlation.different.year
                    if (private$i.metadata[[i,'stratum']] != private$i.metadata[[j,'stratum']]) rv = rv * private$i.parameters$correlation.different.strata
                    if (private$i.metadata[[i,'source']] != private$i.metadata[[j,'source']]) rv = rv * private$i.parameters$correlation.different.source
                    if (private$i.metadata[[i,'source']] == private$i.metadata[[j,'source']] && !setequal(private$i.details[[i]], private$i.details[[j]]))
                        rv = rv * private$i.parameters$correlation.same.source.different.details
                    rv

                })
            })

            measurement.error.sd = private$i.obs.vector * private$i.parameters$measurement.error.coefficient.of.variance
            
            private$i.measurement.error.covariance.matrix =
                measurement.error.correlation.matrix * (measurement.error.sd %*% t(measurement.error.sd))

            ## ---- GENERATE INVERSE VARIANCE WEIGHTS MATRIX ---- ##
            private$i.inverse.variance.weights.matrix = generate.inverse.variance.weights.matrix(obs.vector = private$i.obs.vector,
                                                                                                 equalize.weight.by.year = instructions$equalize.weight.by.year,
                                                                                                 metadata = private$i.metadata,
                                                                                                 weights = private$i.weights)
        },
        check = function() {
            browser()
        }
    ),
    
    private = list(
        
        i.parameters = NULL,
        
        i.outcome.for.data = NULL,
        i.denominator.outcome.for.sim = NULL,

        i.obs.vector = NULL,
        i.details = NULL,
        i.metadata = NULL,
        i.sim.ontology = NULL,
        i.sim.required.dimnames = NULL,
        i.denominator.required.dimnames = NULL,
        i.sim.dimension.values = NULL,
        i.denominator.dimension.values = NULL,
        i.transformation.matrix = NULL,
        i.transformation.matrix.indices = NULL,
        i.transformation.matrix.row.oriented.indices = NULL,
        i.measurement.error.covariance.matrix = NULL,
        i.inverse.variance.weights.matrix = NULL,
        
        do.compute = function(sim, log=T, check.consistency=T)
        {

            sim.numerator.data = sim$get(outcome = private$i.outcome.for.sim,
                                         keep.dimensions = names(private$i.sim.required.dimnames),
                                         dimension.values = private$i.sim.dimension.values
            )
            
            use.poisson = is.null(private$i.denominator.outcome.for.sim)
            if (use.poisson) {
                sim.denominator.data = NULL
                expanded.sim.denominator.data = NULL
            } else {
                sim.denominator.data = sim$get(outcome = private$i.denominator.outcome.for.sim,
                                               keep.dimensions = names(private$i.denominator.required.dimnames),
                                               dimension.values = private$i.denominator.dimension.values)
                expanded.sim.denominator.data = expand.array(sim.denominator.data, dimnames(sim.numerator.data))
            }
            
            # Warning! These don't throw an error when sim.numerator.data isn't long enough!
            mean = get_basic_likelihood_mean(sim.numerator.data,
                                             private$i.transformation.matrix.row.oriented.indices,
                                             length(private$i.obs.vector),
                                             mean = numeric(length(private$i.obs.vector))
            )
            
            sigma = get_basic_likelihood_sigma(sim.numerator.data,
                                               expanded.sim.denominator.data,
                                               private$i.transformation.matrix.indices,
                                               private$i.measurement.error.covariance.matrix,
                                               length(private$i.obs.vector),
                                               sigma = numeric(length(private$i.obs.vector) ^ 2), # maybe define before this?
                                               use.poisson
            )
            
            # # --- #
            sigma = sigma * private$i.inverse.variance.weights.matrix
            
            likelihood = mvtnorm::dmvnorm(private$i.obs.vector,
                                          mean = mean,
                                          sigma = matrix(sigma, nrow=length(private$i.obs.vector), ncol=length(private$i.obs.vector)),
                                          log=T,
                                          checkSymmetry = F)
            
            # verify.matrix.operation.correctness(sim.denominator.data,
            #                                     sim.numerator.data,
            #                                     private$i.transformation.matrix,
            #                                     private$i.measurement.error.covariance.matrix,
            #                                     private$i.inverse.variance.weights.matrix,
            #                                     private$i.obs.vector,
            #                                     likelihood,
            #                                     log)

            
        },
        
        get.likelihood.years = function(from.year,
                                        to.year,
                                        omit.years,
                                        data.manager,
                                        outcome.for.data)
        {
            if (from.year == -Inf || to.year == Inf) {
                data.manager.bounds = data.manager$get.year.bounds.for.outcome(outcome.for.data)
                if (from.year == -Inf)
                    from.year = data.manager.bounds[['earliest.year']]
                if (to.year == Inf)
                    to.year = data.manager.bounds[['latest.year']]
            }
            setdiff(from.year:to.year, omit.years)
        },
        
        generate.inverse.variance.weights.matrix = function(obs.vector,
                                                            equalize.weight.by.year,
                                                            metadata,
                                                            weights)
        {
            weights.vector = rep(1,length(obs.vector))
            
            if (equalize.weight.by.year) {
                obs.per.year = table(metadata$year)
                number.years = length(obs.per.year)
                
                for (year in names(obs.per.year)) {
                    weights.vector[metadata$year == year]  = length(obs.vector) / (obs.per.year[[year]] * number.years)
                }
            }
            
            stratum.names = lapply(metadata$stratum, function(x) {
                unlist(strsplit(x, "__"))
            })
            
            # Once the weights list is in the format list(weights.object1, weights.object2, ...), I'll loop over them.
            for (weight in weights) {
                
                # if no dimension.values, apply it to all observations
                if (length(weight$dimension.values) == 0) {
                    weights.vector = weights.vector * weight$total.weight
                } else {
                    weights.mask = sapply(stratum.names, function(x) {
                        contains.dimension.value = F
                        if (length(x) == length(weight$dimension.values)) {
                            for (d in seq_along(x)) {
                                # NOTE: This assumes the dimensions of the dimension.values are sorted alphabetically. The stratum names are.
                                if (x[[d]] %in% weight$dimension.values[[d]])
                                    contains.dimension.value = T
                                else {
                                    contains.dimension.value = F
                                    break
                                }
                            }
                        }
                        contains.dimension.value
                        
                    })
                    weights.vector[weights.mask] = weights.vector[weights.mask] * weight$total.weight
                }
            }
            
            sqrt.weights.vector = sqrt(1/weights.vector)
            sqrt.weights.vector %*% t(sqrt.weights.vector)
        },
        
        verify.matrix.operation.correctness = function(sim.denominator.data,
                                                       sim.numerator.data,
                                                       transformation.matrix,
                                                       measurement.error.covariance.matrix,
                                                       inverse.variance.weights.matrix,
                                                       obs.vector,
                                                       value.to.compare,
                                                       log)
        {
            sim.denominator.data = as.vector(sim.denominator.data)
            sim.numerator.data = as.vector(sim.numerator.data)

            transformed.numerator.data = transformation.matrix %*% sim.numerator.data

            model.imperfection.error.variance =
                sim.numerator.data * (1 - sim.numerator.data / sim.denominator.data)
            model.imperfection.error.covariance.matrix = diag(model.imperfection.error.variance, nrow=length(model.imperfection.error.variance), ncol=length(model.imperfection.error.variance))

            transformed.model.imperfection.error.covariance.matrix =
                transformation.matrix %*%
                model.imperfection.error.covariance.matrix %*%
                t(transformation.matrix)

            # sigma
            overall.covariance.matrix = measurement.error.covariance.matrix + transformed.model.imperfection.error.covariance.matrix
            overall.covariance.matrix = overall.covariance.matrix * inverse.variance.weights.matrix
            computed.value=mvtnorm::dmvnorm(obs.vector,
                                            mean = transformed.numerator.data,
                                            sigma = overall.covariance.matrix,
                                            log=log,
                                            checkSymmetry = F)
            if (computed.value == value.to.compare)
                print("Outputs match")
            else
                print("Outputs do not match")
        }
    )
)