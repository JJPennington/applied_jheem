

#@Andrew - need to document
#'
#'@param weights An object of class 'jheem.likelihood.weights', generated by \code{\link{create.likelihood.weights}}
#'
#'@export
create.basic.likelihood.instructions <- function(outcome.for.data,
                                                 outcome.for.sim,
                                                 denominator.outcome.for.sim = NULL, # If NULL (as it would be for population), will be doing the Poisson version of compute
                                                 dimensions,
                                                 denominator.dimensions = dimensions,
                                                 levels.of.stratification = NULL,
                                                 from.year = -Inf,
                                                 to.year = Inf,
                                                 omit.years = NULL,
                                                 sources.to.use = NULL,
                                                 correlation.different.years = 0.5,
                                                 correlation.different.strata = 0.1,
                                                 correlation.different.sources = 0.3,
                                                 correlation.same.source.different.details = 0.3,
                                                 observation.correlation.form = c('compound.symmetry', 'autoregressive.1')[1],
                                                 measurement.error.coefficient.of.variance,
                                                 weights,
                                                 equalize.weight.by.year = F)
{
    
    JHEEM.BASIC.LIKELIHOOD.INSTRUCTIONS$new(outcome.for.data = outcome.for.data,
                                            outcome.for.sim = outcome.for.sim,
                                            denominator.outcome.for.sim = denominator.outcome.for.sim,
                                            dimensions = dimensions,
                                            denominator.dimensions = denominator.dimensions,
                                            levels.of.stratification = levels.of.stratification,
                                            from.year = from.year,
                                            to.year = to.year,
                                            omit.years = omit.years,
                                            sources.to.use = sources.to.use,
                                            correlation.different.years = correlation.different.years,
                                            correlation.different.strata = correlation.different.strata,
                                            correlation.different.sources = correlation.different.sources,
                                            correlation.same.source.different.details = correlation.same.source.different.details,
                                            observation.correlation.form = observation.correlation.form,
                                            measurement.error.coefficient.of.variance = measurement.error.coefficient.of.variance,
                                            weights = weights,
                                            equalize.weight.by.year = equalize.weight.by.year
    )
    
}

JHEEM.BASIC.LIKELIHOOD.INSTRUCTIONS = R6::R6Class(
    'jheem.basic.likelihood.instructions',
    inherit = JHEEM.LIKELIHOOD.INSTRUCTIONS,
    
    public = list(
        
        initialize = function(outcome.for.data,
                              outcome.for.sim,
                              denominator.outcome.for.sim,
                              dimensions,
                              denominator.dimensions,
                              levels.of.stratification,
                              from.year,
                              to.year,
                              omit.years,
                              sources.to.use,
                              correlation.different.years,
                              correlation.different.strata,
                              correlation.different.sources,
                              correlation.same.source.different.details,
                              observation.correlation.form,
                              measurement.error.coefficient.of.variance,
                              weights,
                              equalize.weight.by.year)
        {
            super$initialize(outcome.for.data = outcome.for.data,
                             outcome.for.sim = outcome.for.sim,
                             denominator.outcome.for.sim = denominator.outcome.for.sim,
                             from.year,
                             to.year,
                             omit.years,
                             dimensions = dimensions,
                             denominator.dimensions = denominator.dimensions,
                             levels.of.stratification = levels.of.stratification,
                             weights = weights,
                             equalize.weight.by.year = equalize.weight.by.year,
                             likelihood.class.generator = JHEEM.BASIC.LIKELIHOOD) # pass error prefix?
            
            error.prefix = paste0('Error creating basic likelihood instructions: ')
            
            if (!is.character(outcome.for.data) || length(outcome.for.data) > 1 || is.null(outcome.for.data) || is.na(outcome.for.data))
                stop(paste0(error.prefix, "'outcome.for.data' must be a character vector of length 1"))
            if (!is.character(outcome.for.sim) || length(outcome.for.sim) > 1 || is.null(outcome.for.sim) || is.na(outcome.for.sim))
                stop(paste0(error.prefix, "'outcome.for.sim' must be a character vector of length 1"))
            
            correlation.multipliers = c(correlation.different.years=correlation.different.years,
                                        correlation.different.strata=correlation.different.strata,
                                        correlation.different.sources=correlation.different.sources,
                                        correlation.same.source.different.details=correlation.same.source.different.details
            )
            
            for (i in seq_along(correlation.multipliers)) {
                if (!is.numeric(correlation.multipliers[[i]]) || correlation.multipliers[[i]] > 1 || correlation.multipliers[[i]] < 0)
                    stop(paste0(error.prefix, "'", names(correlation.multipliers)[[i]], "' must be an integer between 0 and 1 inclusive"))
            }
            
            # *observation.correlation.form* must be either 'compound.symmetry' or 'autoregressive.1'
            if (!(observation.correlation.form %in% c('compound.symmetry', 'autoregressive.1')) || length(observation.correlation.form) > 1)
                stop(paste0(error.prefix, "'observation.correlation.form' must be either 'compound.symmetry' or 'autoregressive.1'"))
            
            # *measurement.error.coefficient.of.variance* must be ...?
            
            
            private$i.sources.to.use = sources.to.use
            private$i.parameters = list(correlation.different.years = correlation.different.years,
                                        correlation.different.strata = correlation.different.strata,
                                        correlation.different.sources = correlation.different.sources,
                                        correlation.same.source.different.details = correlation.same.source.different.details,
                                        observation.correlation.form = observation.correlation.form,
                                        measurement.error.coefficient.of.variance = measurement.error.coefficient.of.variance
            )
        },
        
        equals = function(other)
        {
            if (!is.null(self$code) && !is.null(other$code))
                self$code == other$code
            else {
                if (is(other, 'jheem.basic.likelihood.instructions'))
                {
                    to.compare.identical = c('description',
                                             'outcome.for.data',
                                             'outcome.for.sim',
                                             'denominator.outcome.for.sim',
                                             'from.year',
                                             'to.year')
                    to.compare.setequal = c('sources.to.use',
                                            'omit.years',
                                            'dimensions',
                                            'denominator.dimensions',
                                            'stratifications')
                    
                    all(sapply(to.compare.identical, function(x) {
                        identical(self[[x]], other[[x]])
                    })) *
                        all(sapply(to.compare.setequal, function(x) {
                            setequal(self[[x]], other[[x]])
                        })) *
                        all(sapply(self$weights, function(x) {
                            any(sapply(other$weights, function(y) {
                                x$equals(y)
                            }))
                        })) *
                        all(sapply(names(self$parameters), function(x) {
                            self$parameters[[x]] == other$parameters[[x]]
                        }))
                } else F
            }
        }
    ),
    
    active = list(
        
        parameters = function(value) {
            if (missing(value)) {
                private$i.parameters
            }
            else
                stop("Cannot modify a jheem.basic.likelihood.instruction's 'parameters' - they are read-only")
        },
        sources.to.use = function(value) {
            if (missing(value)) {
                private$i.sources.to.use
            }
            else
                stop("Cannot modify a jheem.basic.likelihood.instruction's 'sources.to.use' - they are read-only")
        }
        
    ),
    
    private = list(
        i.parameters = NULL,
        i.sources.to.use = NULL
    )
)

# class generator object
JHEEM.BASIC.LIKELIHOOD = R6::R6Class(
    'jheem.basic.likelihood',
    inherit = JHEEM.LIKELIHOOD,
    portable = F,
    
    public = list(
        
        initialize = function(instructions,
                              version,
                              location, #combinations of version and location tell us sublocations
                              data.manager,
                              throw.error.if.no.data,
                              error.prefix)
        {
            super$initialize(instructions = instructions,
                             version = version,
                             location = location,
                             data.manager = data.manager,
                             error.prefix = error.prefix)
            ptm = proc.time()
            
            private$i.parameters = instructions$parameters
            private$i.weights = instructions$weights
            private$i.stratifications = instructions$stratifications
            private$i.outcome.for.data = instructions$outcome.for.data
            private$i.outcome.for.sim = instructions$outcome.for.sim
            private$i.denominator.outcome.for.sim = instructions$denominator.outcome.for.sim
            
            
            ## ---- DETERMINE YEARS FOR SIM METADATA ---- ##
            years = get.likelihood.years(from.year = instructions$from.year,
                                               to.year = instructions$to.year,
                                               omit.years = instructions$omit.years,
                                               data.manager = data.manager,
                                               outcome.for.data = private$i.outcome.for.data)
            
            ## ---- PREPARE DATA STRUCTURES ---- ##
            
            sim.metadata = get.simulation.metadata(version=version,
                                                   location=location,
                                                   from.year = years[[1]],
                                                   to.year = years[[length(years)]])
            
            if(!(private$i.outcome.for.sim %in% sim.metadata$outcomes))
                stop(paste0(error.prefix, private$i.outcome.for.sim, " is not a simulation outcome in this specification"))
            
            private$i.sim.ontology = sim.metadata$outcome.ontologies[[private$i.outcome.for.sim]]
            private$i.sim.ontology[['year']] = as.character(years)
            
            private$i.obs.vector = c()
            
            private$i.details = list() # details can't be in a data frame because its elements (character vectors) may have different lengths
            private$i.metadata = data.frame(year = character(0),
                                            stratum = character(0),
                                            source = character(0)
            )

            mappings.list = list()
            dimnames.list = list()
            private$i.transformation.matrix = NULL
            private$i.sim.required.dimnames = list()
            

            remove.mask = c()

            ## ---- PULL DATA ---- ##
            
            for (strat in private$i.stratifications) {
                keep.dimensions = 'year'
                if (!identical(strat, "")) keep.dimensions = c(keep.dimensions, strat)
                data = data.manager$pull(outcome = private$i.outcome.for.data,
                                         sources = private$i.sources.to.use,
                                         keep.dimensions = keep.dimensions,
                                         dimension.values = list(location=location), # leave this for now. Will get more complicated when we have multi location models
                                         target.ontology = private$i.sim.ontology,
                                         allow.mapping.from.target.ontology = T,
                                         append.attributes = 'details',
                                         debug = F)
                
                
                one.mapping = attr(data, 'mapping')
                one.dimnames = dimnames(data)
                one.obs.vector = as.numeric(data)
                one.details = attr(data, 'details')
                
                one.remove.mask = is.na(one.obs.vector)
                remove.mask = c(remove.mask, one.remove.mask)
                one.obs.vector = one.obs.vector[!one.remove.mask]
                one.details = one.details[!one.remove.mask]
                
                if (is.null(data)) {
                    if (throw.error.if.no.data)
                        stop(paste0(error.prefix, "no data was found for the stratification '", strat, "'"))
                    else {
                        # one.sim.keep.dimensions = NULL
                        one.metadata = NULL
                        one.sim.required.dimnames = list()
                    }
                }
                else {
                    # one.sim.keep.dimensions = one.mapping$get.required.from.dimensions(to.dimensions = names(dim(data))[names(dim(data)) != 'source'])
                    
                    # Metadata will involve melting both arrays (data and details) as well as making "stratum"
                    one.metadata = reshape2::melt(data)
                    
                    one.metadata = one.metadata[!one.remove.mask,]
                    
                    # Recover required dimnames from one.metadata
                    one.sim.required.dimnames = one.mapping$get.required.from.dim.names(lapply(one.metadata[!(colnames(one.metadata) %in% c('source', 'value'))],
                                                                                           function(x) {as.character(unique(x))}))
                    
                    one.metadata = one.metadata[, sort(colnames(one.metadata))]
                    one.metadata['stratum'] = do.call(paste, c(subset.data.frame(one.metadata, select=-c(year, source, value)), sep="__"))
                    one.metadata[is.na(one.metadata$stratum), 'stratum'] = ".TOTAL."
                    one.metadata = subset.data.frame(one.metadata, select = c(year, stratum, source))
                }
                
                # Find the required.dimnames
                for (d in names(one.sim.required.dimnames)) {
                    
                    if (!(d %in% names(private$i.sim.required.dimnames)))
                        private$i.sim.required.dimnames = c(private$i.sim.required.dimnames, setNames(list(one.sim.required.dimnames[[d]]), d))
                    else
                        private$i.sim.required.dimnames[[d]] = union(private$i.sim.required.dimnames[[d]], one.sim.required.dimnames[[d]])
                }
                
                private$i.obs.vector = c(private$i.obs.vector, one.obs.vector)
                private$i.details = c(private$i.details, one.details)
                private$i.metadata = rbind(private$i.metadata, one.metadata)
                
                # save all the one.mappings in a list?
                mappings.list[[length(mappings.list) + 1]] = one.mapping
                dimnames.list[[length(dimnames.list) + 1]] = one.dimnames
                
            }
            
            ## ---- FIND REQUIRED DIMENSION VALUES, ETC. ---- ##
            private$i.sim.dimension.values = private$i.sim.required.dimnames[sapply(names(private$i.sim.required.dimnames),
                                                                                    function(d) {
                                                                                        !identical(private$i.sim.required.dimnames[[d]],
                                                                                                   private$i.sim.ontology[[d]])
                                                                                    })]
            denominator.keep.dimensions = c(instructions$denominator.dimensions, 'year')[c(instructions$denominator.dimensions, 'year') %in% names(private$i.sim.required.dimnames)]
            private$i.denominator.required.dimnames = private$i.sim.required.dimnames[names(private$i.sim.required.dimnames) %in% denominator.keep.dimensions]
            private$i.denominator.dimension.values = private$i.denominator.required.dimnames[sapply(names(private$i.denominator.required.dimnames),
                                                                                                    function(d) {
                                                                                                        !identical(private$i.denominator.required.dimnames[[d]],
                                                                                                                   private$i.sim.ontology[[d]])
                                                                                                    })]

            ## ---- GENERATE TRANSFORMATION MATRIX ---- ##
            # browser()
            # Some data has year ranges
            for (s in seq_along(mappings.list)) {
                one.mapping = mappings.list[[s]]
                one.dimnames = dimnames.list[[s]]
                
                one.transformation.matrix = one.mapping$get.matrix(from.dim.names = private$i.sim.required.dimnames,
                                                                   to.dim.names = one.dimnames[names(one.dimnames) != 'source'])
                # rbind once per source
                for (source in 1:length(one.dimnames[['source']])) {
                    private$i.transformation.matrix = rbind(private$i.transformation.matrix, one.transformation.matrix)
                }
            }
            private$i.transformation.matrix = private$i.transformation.matrix[!remove.mask,]
            
            if (is.null(private$i.transformation.matrix))
                stop(paste0(error.prefix, "no mappings found to align simulation and data ontologies"))
            
            ## ---- GENERATE SPARSE REPRESENTATIONS OF TRANSFORMATION MATRIX ---- ##
            private$i.transformation.matrix.indices = generate_transformation_matrix_indices(private$i.transformation.matrix,
                                                                                                 length(private$i.obs.vector),
                                                                                                 length(private$i.transformation.matrix) / length(private$i.obs.vector))

            private$i.transformation.matrix.row.oriented.indices = generate_transformation_matrix_row_oriented_indices(private$i.transformation.matrix,
                                                                                                                       length(private$i.obs.vector),
                                                                                                                       length(private$i.transformation.matrix) / length(private$i.obs.vector))

            ## ---- GENERATE MEASUREMENT ERROR COVARIANCE MATRIX ---- ##
            measurement.error.correlation.matrix = sapply(seq_along(private$i.obs.vector), function(i) {
                # if (i %% 100 == 0)
                #     print(paste0("Currently on i=", i, " with elapsed time from start of operation: ", (proc.time()-ptm)[['elapsed']]))
                sapply(seq_along(private$i.obs.vector), function(j) {

                    rv = 1
                    if (private$i.metadata[[i,'year']] != private$i.metadata[[j,'year']]) rv = rv * private$i.parameters$correlation.different.year
                    if (private$i.metadata[[i,'stratum']] != private$i.metadata[[j,'stratum']]) rv = rv * private$i.parameters$correlation.different.strata
                    if (private$i.metadata[[i,'source']] != private$i.metadata[[j,'source']]) rv = rv * private$i.parameters$correlation.different.source
                    if (private$i.metadata[[i,'source']] == private$i.metadata[[j,'source']] && !setequal(private$i.details[[i]], private$i.details[[j]]))
                        rv = rv * private$i.parameters$correlation.same.source.different.details
                    rv

                })
            })

            measurement.error.sd = private$i.obs.vector * private$i.parameters$measurement.error.coefficient.of.variance
            
            private$i.measurement.error.covariance.matrix =
                measurement.error.correlation.matrix * (measurement.error.sd %*% t(measurement.error.sd))

            ## ---- GENERATE INVERSE VARIANCE WEIGHTS MATRIX ---- ##
            private$i.inverse.variance.weights.matrix = generate.inverse.variance.weights.matrix(obs.vector = private$i.obs.vector,
                                                                                                 equalize.weight.by.year = instructions$equalize.weight.by.year,
                                                                                                 metadata = private$i.metadata,
                                                                                                 weights = private$i.weights)
        },
        check = function() {
            browser()
        }
    ),
    
    private = list(
        
        i.parameters = NULL,
        i.weights = NULL,
        i.stratifications = NULL,
        
        i.outcome.for.data = NULL,
        i.outcome.for.sim = NULL,
        i.denominator.outcome.for.sim = NULL,

        i.obs.vector = NULL,
        i.details = NULL,
        i.metadata = NULL,
        i.sim.ontology = NULL,
        i.sim.required.dimnames = NULL,
        i.denominator.required.dimnames = NULL,
        i.sim.dimension.values = NULL,
        i.denominator.dimension.values = NULL,
        i.transformation.matrix = NULL,
        i.transformation.matrix.indices = NULL,
        i.transformation.matrix.row.oriented.indices = NULL,
        i.measurement.error.covariance.matrix = NULL,
        i.inverse.variance.weights.matrix = NULL, #not yet defined anywhere
        
        do.compute = function(sim, log=T, check.consistency=T)
        {
            # browser()
            if (!all(private$i.sim.required.dimnames[['year']] %in% sim$from.year:sim$to.year))
                stop(paste0("error computing likelihood: simulation does not have all the years for which data was found"))
            # browser()
            sim.numerator.data = sim$get(
                outcome = private$i.outcome.for.sim,
                keep.dimensions = names(private$i.sim.required.dimnames),
                dimension.values = private$i.sim.dimension.values
            )
            
            use.poisson = is.null(private$i.denominator.outcome.for.sim)
            if (use.poisson) {
                sim.denominator.data = NULL
                expanded.sim.denominator.data = NULL
            } else {
                sim.denominator.data = sim$get(outcome = private$i.denominator.outcome.for.sim,
                                               keep.dimensions = names(private$i.denominator.required.dimnames),
                                               dimension.values = private$i.denominator.dimension.values)
                expanded.sim.denominator.data = expand.array(sim.denominator.data, dimnames(sim.numerator.data))
            }
            

            # browser()
            # --- For verification --- #
            # 
            # sim.denominator.data = as.vector(sim.denominator.data)
            # sim.numerator.data = as.vector(sim.numerator.data)
            # 
            # transformed.numerator.data = private$i.transformation.matrix %*% sim.numerator.data
            # 
            # model.imperfection.error.variance =
            #     sim.numerator.data * (1 - sim.numerator.data / sim.denominator.data)
            # model.imperfection.error.covariance.matrix = diag(model.imperfection.error.variance, nrow=length(model.imperfection.error.variance), ncol=length(model.imperfection.error.variance))
            # 
            # transformed.model.imperfection.error.covariance.matrix =
            #     private$i.transformation.matrix %*%
            #     model.imperfection.error.covariance.matrix %*%
            #     t(private$i.transformation.matrix)
            # 
            # # sigma
            # overall.covariance.matrix = private$i.measurement.error.covariance.matrix + transformed.model.imperfection.error.covariance.matrix
            # overall.covariance.matrix = overall.covariance.matrix * private$i.inverse.variance.weights.matrix
            # a=mvtnorm::dmvnorm(
            #     private$i.obs.vector,
            #     mean = transformed.numerator.data,
            #     sigma = overall.covariance.matrix,
            #     log=T,
            #     checkSymmetry = F)
            # --- #
            
            
            # Warning! These don't throw an error when sim.numerator.data isn't long enough!
            mean = get_basic_likelihood_mean(sim.numerator.data,
                                             private$i.transformation.matrix.row.oriented.indices,
                                             length(private$i.obs.vector),
                                             mean = numeric(length(private$i.obs.vector))
            )
            
            sigma = get_basic_likelihood_sigma(sim.numerator.data,
                                               expanded.sim.denominator.data,
                                               private$i.transformation.matrix.indices,
                                               private$i.measurement.error.covariance.matrix,
                                               length(private$i.obs.vector),
                                               sigma = numeric(length(private$i.obs.vector) ^ 2), # maybe define before this?
                                               use.poisson
            )
            
            # browser()
            # # --- #
            sigma = sigma * private$i.inverse.variance.weights.matrix
            
            b=mvtnorm::dmvnorm(private$i.obs.vector,
                             mean = mean,
                             sigma = matrix(sigma, nrow=length(private$i.obs.vector), ncol=length(private$i.obs.vector)),
                             log=T,
                             checkSymmetry = F)

            
        },
        
        get.likelihood.years = function(from.year,
                                         to.year,
                                         omit.years,
                                         data.manager,
                                         outcome.for.data)
        {
            if (from.year == -Inf || to.year == Inf) {
                data.manager.bounds = data.manager$get.year.bounds.for.outcome(outcome.for.data)
                if (from.year == -Inf)
                    from.year = data.manager.bounds[['earliest.year']]
                if (to.year == Inf)
                    to.year = data.manager.bounds[['latest.year']]
            }
            setdiff(from.year:to.year, omit.years)
        },
        
        generate.inverse.variance.weights.matrix = function(obs.vector,
                                                            equalize.weight.by.year,
                                                            metadata,
                                                            weights)
        {
            weights.vector = rep(1,length(obs.vector))
            
            if (equalize.weight.by.year) {
                obs.per.year = table(metadata$year)
                number.years = length(obs.per.year)
                
                for (year in names(obs.per.year)) {
                    weights.vector[metadata$year == year]  = length(obs.vector) / (obs.per.year[[year]] * number.years)
                }
            }
            
            stratum.names = lapply(metadata$stratum, function(x) {
                unlist(strsplit(x, "__"))
            })
            
            # Once the weights list is in the format list(weights.object1, weights.object2, ...), I'll loop over them.
            for (weight in weights) {
                
                # if no dimension.values, apply it to all observations
                if (length(weight$dimension.values) == 0) {
                    weights.vector = weights.vector * weight$total.weight
                } else {
                    weights.mask = sapply(stratum.names, function(x) {
                        contains.dimension.value = F
                        if (length(x) == length(weight$dimension.values)) {
                            for (d in seq_along(x)) {
                                # NOTE: This assumes the dimensions of the dimension.values are sorted alphabetically. The stratum names are.
                                if (x[[d]] %in% weight$dimension.values[[d]])
                                    contains.dimension.value = T
                                else {
                                    contains.dimension.value = F
                                    break
                                }
                            }
                        }
                        contains.dimension.value
                        
                    })
                    weights.vector[weights.mask] = weights.vector[weights.mask] * weight$total.weight
                }
            }
            
            sqrt.weights.vector = sqrt(1/weights.vector)
            sqrt.weights.vector %*% t(sqrt.weights.vector)
        }
    )
)